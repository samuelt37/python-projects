 ICS-33 Overview<body>

 
 Overview 
 
  ICS-33: Intermediate Programming 
 
  




 
       Introduction  
 
This lecture will overview four topics related to this course:
  Learning: what material will we cover in ICS-33
    Computing/Human Resources:  what resources are available
        (and how we will learn to use them).
    Perspectives on Programming: a short discussion of programming and
        education built around 
 
       Quotes 
        that I have collected on my web page (there are hundreds there)
    Software Production: This is some "big picture" material that I present
        to introductory programming students.
      Especially interesting is the table on
       Software Project Metrics 
  
This lecture, like the ones to follow, has a problem set at the end.
But instead of doing these problems with the reading -because this
  is the first day of class- we will spend time in class looking at and
   solving these problems.
They mostly concern the precise use of a natural language: there are many
  parallels here to the precise use of a programming langauge.
 
    
  Course Goals 



       
   A Third Course in Programming  
 
Here is a quick overview of the the three programming class in UCI's three
  quarter Introduction to Programming sequence.
All are taught in Python, and the combined time-on-task studying and
  programming with this language should make students proficient in using it.
  ICS-31: Introduction to Programming.
    This course introduces the basics of the Python programming language and
      how to develop programs in an Integrated Development Environment
      (Eclipse or IDLE) using Python.
  ICS-32: Programming With Software Libraries.
    This course increases students' abilities to write more complicated
      programs; it focuses on students learning how to read, understand, and
      employ modules (and classes) from Python's library.
  ICS-33: Intermediate Programming.
    This course examines Python more carefully, giving students a more unified
      look at the language and discussing some of its powerful features that
      make sophisticated programming easier.
    It also covers some programming related Computer Science topics.
  
A quick way to analogize these courses is: 31: learning to drive; 32: road
  trips; 33: car mechanics.
 
I expect students to come into ICS-33 having had 20 weeks worth of
  progamming experience; many have be struggling hard to learn to program in
  Python, and to understand and integrate what they have learned.
Students at this stage are often "cargo-cult" programmers, working more by
  superstition than a deep understanding of the Python programming language.
  
My goal in ICS-33 is for students to solidify their basic understanding of
  Python and to extend their knowledge.
We will do so by exploring new Python language features and re-examining old
  ones, in light of what we learn (and the new build on the old).
The material we cover needs to be understood thoroughly, so that we can apply
  it in complex and novel situations, not just memorized; by mastering the tool
  that is Python, we can build all sorts of useful software with it.
  
We will also cover some Computer Science topics that are closely related to
  programming.
In addition, students will be introduced to some new tools:
  modules (regular expressions and unit tests) and software 
 (Eclipse Integrated Developement Environment and its Debugger Perspective).
  
The intellectual content of this course can be roughly categorized into three 
  main areas (although some topics bridge multiple areas):
  Classes, Functions, and Computer Science.
     Classes: operator overloading, (iterator) protocols, inheritance, and
          self-referential classes.
      Functions: lambdas, generators, recursion, and functional programming.
      Computer Science: EBNF//regular expressions, decorators, analysis of
           programming, unit-testing, and (Java and) static typing.
      
    




        Expectations for Learning  
 
As members of a course, working together in teaching and learning, we should
  share the following expectations.

   
  
 Instructor: 
   Starts and stops class on time.
    Assigns the minimal amount of homework, but enough so that students learn
        all the required material and are comfortable programming.
         ICS-33 is a 4 unit course.
            At UCI, each unit typically requires 3 hours/week of work, which
              means you should spend about 12 hours/week working on ICS-33.
            Of this 12 hours, 7 hours/week will be in-class lecture/lab,
              leaving 5 hours/week for lecture prepartion, quizzes, and
              programming.
           Distributes course materials in a timely manner.
    Returns solutions/graded homework promptly.
    Is available for providing individual help.
   Student: 
  Attends class, is punctual, and participates (does reading, asks/answer
        questions).
    Completes all homework, spending the requisite time to learn all the
         required material.
    Studies course materials (READ! READ! READ!) and is prepared for class.
    Examines solutions/graded homework to improve knowledge and rectify
        misconceptions about the course material (and promptly reports any
        possible grading mistakes).
    Seeks individual help when it is needed.
  
The biggest source of problems for students taking ICS-33 is skipping classes,
  not doing readings/homework fully, and poor time management on programming
  assignments (waiting too long to start them, or not making sufficient
  daily progress on them).
You are scheduled to spend about 120 hours in ICS-33 (10 weeks of work at 12
  hours/week); please allow for this much time in your schedule, and use this
  time wisely.
 
I believe that with the right attitude and work ethic, any UCI student can
  learn (and demonstrate that he/she has learned) the material required for
  ICS-33, and pass this course.
But it does take a desire to do so, and the action necessary on your part.
  
    



 
  Resources 




         The Course Web  
 
I will place all materials for this course on the course web: some are there
  now, others will become available later in the quarter.
You will also use the web for submitting programs for grading.
These materials are organized using the following index on the course
  home page.
   
Here is a brief description of these main entries
   Fact Sheet : A page providing information about course
           staff, getting help, and meeting times; this is the home-page for
           the course.
     Announcements : A page archiving messages I send to the
           class, typically on a weekly basis.
     Email Archive : A page archiving all email I send to the
           class, typically on a daily basis.
     MessageBoard Forums : A page holding various forums on which
           students can post questions to get answers from the ICS-33 staff or
           other students.
     Syllabus : A link to a long page providing detailed information
           about the mechanics of how this course is run (print a copy).
   
      Lecture Schedule/Notes : A page indexing all lectures and labs,
         their on-line lecture notes, and their associated problem sets.
     Weekly Schedule : A page listing all readings and homework
         assignments (and their due dates), week by week; contains more detail
         than the  Lecture Schedule/Notes  link.
     Programming Assignments : A page indexing all programming
         assignments, including their assign/due dates.
   
      Handouts (General) : A page indexing a variety of handouts related
         to the course.
     Course Software : A page indexing course software (most useful
          at the start of the course, for downloading and installing Java,
          Python, and Eclipse).
     Sample Programs : A page indexing various programs students can
           download, examine, and run.
   
      Python Langauge Reference : An online reference to the Python
           language; it may be a bit to high-level for beginning programmers
     Python Library Reference : An online reference to the Python
           library; it may be a bit to high-level for beginning programmers
     Course Library Reference : Documentation of the modules in ICS-33's
          standard Python classes.
   
      Solutions (in EEE Drop Box) : A page indexing my solutions to all
           course assignments (quizzes, programs, and exams); updated as
           appropriate
     Grades (zippled .xlsm file) : A zipped file you can download with
           all your course grades (indexed by your ID Hashed: see below)
     Find ID Hashed (grade key) : Find your ID Hashed for this course, to
           locate your grade information in spreadsheets
   
      Send Anonymous Email to INSTRUCTOR : A page students can use to
           send the instructor anonymous email
           (when personal email might be awkward).
         Don't ask a question: I won't know whom to answer.
   
      Checkmate Homework Dropoff : A page students use to submit their
           homework: quizzes and weekly programming assignments.
   
      Local Site Search : Searches the ICS-33 website for the information
           entered in the textbox, when  ICS-33 Search  isn clicked.
    
During this course you will be constantly reading web pages, and sometimes
  downloading materials from them onto your computer.
Generally, it is critical to become an expert navigating the course web with a
  browser; specifically you should become familiar with the pages used 
  repeated in this course (so that you can easily find all the materials you
  need).
 
If you run across any "missing links", please drop me a short e-mail so that I
  can correct them quickly.
  
    




        Computer Labs and Software  
 
I expect that most students will use their own computers for programming
  assignments.
You are encouraged to use your own computer for all aspects of the course that
  it is capable of supporting.
You can download all the required course software to your personal computer for
  free.
 
In addition to using their own machines, students can do their coursework on
  the machines in the  ICS Labs .
The main upside of using the ICS labs is that it will be easy to get ICS-33
  staff to help you there.
All labs are located in in the ICS building, in rooms 180, 189, 192, and 364.
  
ICS courses often schedule lab hours (to complement lecture hours), during
  which students can learn how to use software tools and work on their
  programming assignments, all under the supervision of ICS staff members.
We will have 4 hours of lab scheduled each week in ICS-33.
  
All the machines in the ICS Labs run Windows 7 and are loaded with all the
  necessary course software: browsers, the Eclipse Integrated Development
  Environment (IDE), Python, and all the other course-related
  software.
These labs provide a convenient space for students to work on their assignments
  where the course staff is available to answer questions immediately.
  
    




        Human Resources  
 
Students start ICS-33 with a wide variety of aptitudes and skills. 
At times, even the best students run into problems, misconceptions, mental
  roadblocks, etc.
It is imperative that you quickly determine that you have a problem, and then
  get it diagnosed and corrected as soon as possible.
There are many different resources that you can elect to use:
   Instructor : From my perspective, the best place to get help is
           from me; the biggest problem is that I'm typically teaching hundreds
           of students each quarter.
         Still, I have office hours most days; these are open office hours: no
           appointment is necessary.
         If you cannot see me during any of these times, you  can contact me 
           by e-mail or contact me during my online office hours M-Th and Su.
     TAs : The Teaching Assistants will supervise the labs.
         They are there primarily to help you debug your programs, and explain
           gaps or misconception in your knowledge of Python.
         Your TA is also responsible for grading your programs, so he/she is the
            first person you should see if you have any questions about how your
            programming assignments were graded.
         The TAs will aid me grading quizzes and exams.
     Lab Tutors : Lab Tutors will help the TAs in  the labs.
         They are there primarily to help you debug your programs, and explain
           gaps or misconception in your knowledge of Python.
     Students : I encourage students in my courses to seek out each
           other if they have questions.
         The student answering the question will benefit as much as the student
            asking it.
         One beneficial reason to come to UCI is for the interaction with other
           outstanding students.
      Of course, for graded materials there are dos and don'ts related to
           getting help, to ensure academic integrity; follow these rules.
  
The most useful online mechanism for handing questions/discussions is EEE's
     
    MessageBoard Forums  (easily reachable from the course web's index).
These forums allow students to ask questions (or start discussions) easily, as
  well as supply answers (or participate in the discsussion further).
Initially, I have created four forums for ICS-33:
  Python and Eclipse
  Lecture Material
  Programming Assignments
  Quizzes and Exams
  
If the need arises for other forums (tell me if you think another would be
  useful), I will create them.
You can instruct EEE to email you links to any active discussions in the
  forums.
In past quarters, these forums have seen a tremendous amount of traffic: course
  material has been clarified, questions have been asked and answered, and many
  interesting side-discussions have ensued.
But the efficacy depends on your participation.
 
I will broadcast information to all the students (and staff) in ICS-33
  using the   ICS-33 Email List 
  (ics33-W17@classes.uci.edu).
All students and staff in the course will automatically receive emails sent to
  this address and all messages sent via this discussion list will be archived
  on the
     
    Email Archive  (easily reachable from the course web's index).
Most student-initiated questions/discussions should use the forums mentioned
  above, but sometimes students can use this email list to inform the
  instructor, staff, and other students about some timely issue: e.g.,
  Checkmate not responding to program submissions.
  
Learning when and how to seek help from others is an important skill to acquire
  -one that you will use continually in your professional career.
For example, if you encounter a programming problem that you cannot solve in 5
  minutes (and see no further steps toward a solution), you should be able to
  explain the problem concisely (using all the programming terminology that you
  have learned) to someone else, and then understand and apply an informed
  answer, possibly collaborating to reach a solution.
  
Instructors, TAs, and Lab Tutors all have experience handling such questions,
  and are trained to help students learn to become more self-sufficient
  -while still answering their questions: for example, we might tell you a
  general technique for solving a collection of similar problems instead of 
 just telling you "the answer".
Sometimes this process is a bit frustrating for students seeking help
  (especially if they started the assignment late and are caught in a
  time-bind), but ultimately this approach makes them better programmers.
The appropriate homily is,  "Give a person a fish and you feed them for a
  day; teach a person to fish and you feed them for life." 
  
Think seriously about using the human resources that UCI provides (which
  includes me, our TAs, and Lab Tutors, and your fellow
  students), just as you would think about using computational resources:
  the former resources are even more important than the latter.
  
 Knowing when (and how) to seek help is a strength, not a weakness. 
  
          A Bit about Me    
 
I hope to get to know you all individually during the quarter.
Here is some information about me.
 
I grew up on the North Shore of Chicago (in the town of Wilmette) and attended
   New Trier West High School.
I was an undergraduate Mathematics major at Carnegie Mellon University (CMU)
  from 1972-1975, after which I taught a introductory programming there for a
  year.
I went to graduate school in Computer Science at Stanford.
While there, I wrote a book,  Karel the Robot: A Gentle Introduction to the
  Art of Programming , and its associated software (since updated by Mark
  Stehlik and Jim Roberts at CMU).
Over the years, my book has been revised and extended by Joe Bergin to C++,
  Java, and now Python, and it is still used in Colleges and High Schools
  around the world.
  
From 1985-1995 I taught introductory and intermediate programming at the
  University of Washington in Seattle (sending lots of my students to work
  at the relatively new company, Microsoft; the times allowed many of them to
  become millionaires).
From 1996-2007 I returned to teach at CMU; for the last two years there,
  I served as the Freshman Advisor for incomming Freshman in Computer
  Science (about 150/year).
In 2007, I joined the Bren School of Information and Computer Science (with
  a joint appointment in Computer Science and Informatics), returning to teach
  in a public university (where my wife was the founding director of the
  Nursing program; she now works at USC).
  
During my Freshman year in high school, I had a Math teacher named Mr. Lill.
One class, during a test, my mechanical pencil broke.
I asked Mr. Lill to borrow one of his pencils; but he said no.
I asked him whether I could borrow a friend's pencil; but he said no to that
  too.
He told me to always come prepared to class, and sat me back down at my desk
  (where I failed the test because I was unable to write any answers).
I had a very low opinion of Mr. Lill for a long time -for years, and I thought
  about this incident for many years; but he taught me an important lesson that
  stayed with me much longer than the mathematics he taught.
I hope I don't have to be anyone's "Mr. Lill", but I will assume that role if
  necessary: there are lots of lessons to be taught at UCI and not all of them
  concern the content of the course material.
  
I have posted this story on my course web pages for many many years.
Amazingly, in 2009, when I was attending a reception for students
  admitted to ICS at UCI, I started talking with a student and his parents.
Offhandedly I asked where the father grew up; it was near me; I asked what
  high school he went to; it was mine; I asked what year he started; it was
  the same year that I started!
At that point we exchanged names, and recognized each other: we were not
  close friends in High School and had not seen each other since graduation.
The absolute first comment he made to me was, "Do you remember the day in Mr.
  Lill's class when he wouldn't let you borrow the pencil."
I was totally floored.
Obviously the lesson that I learned so painfully that day was also learned by
  many others, but at a lesser cost.
  
As a senior in High School I wanted to take both AP Chemistry and AP Physics,
  but they were scheduled at the same time.
I had great respect for and enjoyed being in the classroom with the Chemistry
  teacher, Mr. Koonz, so I signed up for AP Chemistry.
I asked the AP Physics teacher for a list of all the problems that he assigned
  from the textbook, and spent the year reading the book and working those
  problems (the book had answers -but not worked solutions, so I could see if
  I was right, but not know why not if I was wrong- for many of those problems
  in the back).
The result was that I discovered that I could learn by myself, from what are now
  considered very rudimentary learning materials (compared to the internet).
A big goal of college is to teach students to be able to learn by themselves.
  
          Student Feedback  
 
The most interesting short comment that I received on a Faculty/Course
  Evaluation form (FCE) was, "You teach  a biased class."
After some reflection, I had to agree with that student 100%.
Almost everything I do in my class is highly biased: choosing which programming
  topics to teach, how to sequence these topics (which ones to emphasize, which
  ones to relegate as mere details), deciding programming assignments and test
  questions (and how to award credit for these problems), etc.
You are sitting in my classroom because you have decided to obtain the UCI
  bias on how to learn programming.
 
I once read a book written about MIT.
The author observed that everyone there majored in the same thing: MIT.
Yes, they all learned a different vocabulary and facts, and practiced reasoning
   and problem solving in different disciplines, but what everyone really was
   doing there was learning to think like an MIT graduate.
Along these lines, I want you to eventually acquire a Pattis simulator in
  your head.
By running it, you can determine how I would approach a problem; how I would
  critique a solution, etc.
You don't have to agree with the results it produces, but it is there for
  you to consult.
  
The most interesting long comment I received on a course evaluation form was
labeled  A Relevant Allegory :
  
 
  "In order to teach someone to boil water, he would first spend a day giving
     the history of pots, including size, shape, and what metals work best.
   The next day he'd lecture on the chemical properties of water.
   On day three, he'd talk about boiled water through the ages.
   That night, he'd tell people to go home and use boiled water to make
     spaghetti carbonera.
   But never once would he tell you to put the water in the pot and heat it.
   That's what his programming classes are like -completely irrelevant to the
     task at hand."
 
     
I like this comment because it is witty, well-written, and true -although
  maybe not in the extreme that the author states.
Teaching students to boil water is great for a high school class, but
  in college we are trying to achieve something deeper: we might, instead,
  study phase transitions in matter.
That is, we don't just learn particulars (drill and practice); we learn
  general theories and -in spite of what this student says- how to apply
  them to particular cases.
I want to teach programming in such a way that when students are exposed to
  new and novel situations, they will be able to use their general knowledge
  to fall back and analyze the problem, figure out what they know and what
  they need to learn to solve the problem, and ultimately synthesize a
  solution.
I acknowledge that learning from first principles is tougher than memorization,
  and that sometimes students feel that the material covered is not "applied".
But I believe that everything that I teach has many concrete applications.
  
The following quote comes from an
   
  article  written by Dr. Peter J. Fabri for the Americal College of
  Surgeons.
  
 
"The aim of education is broader than training.
It strives to prepare learners to be analytical thinkers and problem solvers by
  facilitating the learning of principles, concepts, rules, facts, and
  associated skills and values/attitudes.
Its aim is to develop residents understanding, abilities to synthesize
  information, and work skills within and beyond the workplace.
Therefore, it often includes what might be considered generic or general topics
  without a specific, immediate application."
 
  
    
  Learning a Programming Language 




        Learning  
 
In this section I'd like to work from the general to the specific,
  from education to programming, illustrated with various
   
    Quotes 
  I have collected on my web page.
Let's start with three interesting quotes: the first from a graduate student
  at the University of Washington, and the second from Jacob Bronowski, a
  distinguished philosopher of science, the third from Edward Teller, a
  physicist.
 
    
There is a division in the student population between those who go to college
  to learn and those who go to college to earn a diploma. 
  - J. Blau (letter to the editor, Chronicle of Higher Education, May 24, 2002) 
  
     
It is important that students bring a certain ragamuffin, barefoot irreverance
  to their studies; they are not here to worship what is known, but to
  question it.
  - J. Bronowski 
  
     
I believe in excellence.
It is a basic need of every human soul.
All of us can be excellent, because, fortunately, we are exceedingly diverse
  in our ambitions and talents. 
  - E. Teller 
     
You have to decide why you are attending UCI.
Your choice will have a lot to say about what you do in this class and others.
Here is a simple question that makes it concrete:
  which of the following students would you rather be?
Student 1 attends UCI, but on graduation day is informed that all records of
  the student's performance at UCI have been lost; in the future, UCI will
  acknowledge only that the student attended for four years and graduated
  with an ICS degree, but there are no more details to tell.
Student 2 attends UCI, but on graduation day is hit on the head and develops
  amnesia; although UCI shows the student to have graduated with a 4.0 in CS,
  the student cannot remember any of the material learned through those four
  years.
  
I enjoy teaching because I am constantly challenged by students to think more
  deeply about what I know and how I can teach it.
Teaching as best as I can is my job; challenging what you hear -to better
   understand it and question my knowledge of the subject- is yours.
Such challenges make me rethink and revise my opinions (more than you might
  imagine) and think about better ways of presenting and explaining
  complicated material.
  
Everyone can excel in Computer Science at UCI: different students will
  gravitate torwards different parts of the field, but it is a big field -with
  many connections to applications in other disciplines- and there is room for
  everyone to be excellent at something.
Many of you will be excellent at programming; some of you will be good at it,
  and that will be enough for you.
But, everyone should acquire a basic understanding and basic skills in
  programming.
  
Just as I question myself, a huge part of learning requires students to
  question themselves (and, as seen above, me as well).
Learning is more about questions than answers, as the following quotes
  illustrate.
  
    
Good teaching is more a giving of the right questions than a giving of the
   right answers.
  - J. Albers 
  
A prudent question is one-half of wisdom.
   - F. Bacon 
  
Questions are the important thing, answers are less important.
Learning to ask a good question is the heart of intelligence.
Learning the answer---well, answers are for students.
Questions are for thinkers. 
   - R. Schank (in "The Connosseur's Guide to the Mind") 
  
The function of genius is not to give new answers, but to pose new questions
   which time and mediocrity can resolve. 
   - H. Trevor-Howard 
  
     
When the physics nobel-laureate I. Rabi was a child, his mother would
  always ask him at the dinner table not what he learned in his classes that
  day, but what interesting questions he asked.
  
Neil Postman, a famous education, technology, and media critic tells the
  following story about the importance of asking the right question:
  
Two priests were arguing about whether it was appropriate to pray and
  smoke at the same time.
They each resolved to ask their bishop for guidance.
When they met again, each claimed that the bishop supported his position!
They went on to explore their interactions with the bishop in a bit more
  detail.
The first said, "I asked the bishop whether it was appropriate to smoke while
  praying, and he said that praying is a transcendant activity that should not
  be debased by smoking."
The second said, "I asked the bishop whether it was appropriate to pray while
  smoking, and he said that praying was appropriate any time."
 
I know that students enrolled in this course have all already learned Python
  programming, but different students will have learned/retained different
  amounts.
I urge everyone to use this quarter to attain a deeper, more integrated
  understanding of what they already know, as the following quote illustrates.
 
    
The voyage of discovery is not in seeking new landscapes but in having new
  eyes.
  - M. Proust 
     
Of course, everyone will build on this material to learn more.
Remember too, that teaching and learning are two different, but cooperative
  activities.
I'll do my best to teach, but you need to do your best to learn as well.
  
    
We think too much about effective methods of teaching and not enough about
  effective methods of learning.
No matter how good teaching may be, each student must take the responsibility
  for his own education. 
  - J. Carolus S.J. 
  
Learning results from what the student does and thinks, and only from what
  the student does and thinks.
The teacher can advance learning only by influencing the student to learn.
   - H. Simon 
  
The truth is, when all is said and done, one does not  teach a subject ,
  one teaches a student how to learn it.
Teaching may look like administering a dose, but even a dose must be worked
  on by the body if it is to cure.
Each individual must cure his or her own ignorance.
   - J. Barzun ("Begin Here", pp 35),  
     
Here is an old joke that illustrates this idea:
  
One day a mother comes home from work and asks her son, "What did you do
  today?"
The son replied, "I taught our dog how to play the piano."
The mother, incredulous, asked, "Our dog can play the piano?", to which the
  son laughed and replied, "Of course not mom. I said that I taught him; I
  didn't say that he learned how." 
 
Finally, don't be afraid to "struggle" and "fail"; if learning were
  simple and effortless, we'd all be a lot smarter.
 
    
I, myself, have had many failures and I've learned that if you are not failing
  a lot, you are probably not being as creative as you could be -you aren't
  stretching your imagination. 
  - J. Backus (primary inventor of FORTRAN) 
  
Learning is never done without errors and defeat. 
   - V. Lenin 
  
You have to honor failure, because failure is just the negative space around
  success. 
   - R. Nelson (in Wired 06/2004 page 166) 
  
I have learned throughout my life as a composer chiefly through my mistakes
  and pursuits of false assumptions, not my exposure to founts of wisdom and
  knowledge. 
   - I. Stravinsky 
  
I am always doing that which I cannot do, in order that I may learn how to do
  it.
   - P. Picasso 
     

Unfortunately, the K-12 educational world that we live in doesn't encourages
  students to try (at really hard things) and fail.
Everyone wants to make sure they never fail.
This attitude is bad in many dimensions.
College is a safe place to try hard and fail (and succeed eventually too);
  mistakes are failures only if you don't learn from them.
  
          Language  
 
Let's leave learning behind (but not for too long!) and talk a bit
  about language.
This course is meta-lingual: we will use a language (English) to learn a
  language (Python).
Some argue, as illustrated below, that language is what reality (and
  certainly education) is primarily about: independent of the subject
  material, thoughts are linguistic.
 
As a concrete example, we will learn lots of technical terms during the
 first few weeks of the course, and then use them repeated as levers to
  explore and describe advanced Python concepts.
When it comes time to ask questions about the material, or questions about
  debugging a program that you are writing, knowing how to ask using these
   technical terms -and understand the answers given in these technical terms-
   makes the process more precise and concise.
In an important sense, this course is concerned not only about
  doing programming, but just as much with how to talk about programs and 
  talk about doing programming.
  
    
That language is an instrument of human reason, and not merely a medium for the expression of thought, is a truth generally admitted. 
  - G. Boole 
  
The real technology -behind all our other technologies- is language.
It actually creates the world our consciousness lives in.
   - A. Codrescu 
  
It is wrong to think that the task of physics is to find out how nature is.
Physics concerns what we say about nature.
   - N. Bohr 
  
Precise language is not the problem. Clear language is the problem.
   - R. Feynman 
  
We think only through the medium of words.
Languages are true analytical methods.
Algebra, which is adapted to its purpose in every species of expression, in
  the most simple, most exact, and best manner possible, is at the same time
  a language and an analytical method.
The art of reasoning is nothing more than a language well arranged. 
   - A. Lavoisier 
  
Knowledge of a subject means knowledge of the language of that subject, which
 includes not only what its words mean, but far more important, how its
 words mean.
As one learns the language of a subject, one is also learning what the subject
  is.
It cannot be said often enough that what we call a subject consists mostly,
  if not entirely, of its language. If you eliminate all the words of a
  subject, you have eliminated the subject.
Biology is not plants and animals.
It is language about plants and animals.
History is not events.
It is language describing and interpreting events.
Astronomy is not planets and stars. It is a way of talking about planets and
  stars.
   - N. Postman 
  
Language serves not only to express thought but to make possible thoughts which could not exist without it. 
   - B. Russell 
  
The limits of your language are the limits of your world. 
   - L. Wittgenstein  
     
          Programming  
 
Finally, let's talk about programming and programming languages.
Most of the quotes below are lengthy, and come from emminent computer
  scientists (or just fantastic programmers) who are trying to communicate
  what programming is about and why it is so fascinating to them.
 
    
The programmer, like the poet, works only slightly removed from pure
  thought-stuff.
He builds castles in the air, from air, creating by exertion of the
  imagination.
Few media of creation are so flexible, so easy to polish and rework, so
  readily capable of realizing grand conceptual structures.
Yet the program construct, unlike the poet's words, is real in the sense that
  it moves and works, producing visible outputs separate from the construct
  itself.
It prints results, draws pictures, produces sounds, moves arms.
The magic of myth and legend has come true in our time.
One types the correct incantation on a keyboard, and a display screen comes to
  life, showing things that never were nor could be. ...
The computer resembles the magic of legend in this respect, too.
If one character, one pause, of the incantation is not strictly in proper
  form, the magic doesn't work.
Human beings are not accustomed to being perfect, and few areas of human
  activity demand it.
Adjusting to the requirement for perfection is, I think, the most difficult
  part of learning to program. 
  - F. Brooks ("The Mythical Man Month", pages 7-8) 
  
It's [programming] the only job I can think of where I get to be both an
  engineer and an artist.
There's an incredible, rigorous, technical element to it, which I like because
  you have to do very precise thinking.
On the other hand, it has a wildly creative side where the boundaries of
  imagination are the only real limitation. 
   - A. Hertzfeld (original Mac programmer) 
  
When I speak about computer programming as an art, I am thinking primarily of
  it as an art form, in an aesthetic sense.
The chief goal of my work as an educator and author is to help people learn
  how to write beautiful programs ... 
My feeling is that when we prepare a program, the experience can be just like
  composing poetry or music ...
Some programs are elegant, some are exquisite, some are sparkling.
My claim is that it is possible to write grand programs, noble programs, truly
  magnificent ones!  ...  computer programming is an art, because it applies
  accumulated knowledge to the world, because it requires skill and ingenuity,
  and especially because it produces objects of beauty.
Programmers who subconsciously view themselves as artists will enjoy what they 
 do and will do it better. 
   - D. Knuth (Computer Programming as an Art. Turing Award Speech 1974) 
  
A good programming language is a conceptual universe for thinking about
  programming. 
A language that doesn't affect the way you think about programming is not
  worth knowing. 
   - A. Perlis 
  
A programming language is a system of notation for describing computations.
A useful programming language must therefore be suited for both description
 (i.e., for human writers and readers of programs) and for computation
 (i.e., for efficient implementation on computers).
But human beings and computers are so different that it is difficult to find
  notational devices that are well suited to the capabilities of both. 
   - R. Tennant (Principles of Programming Languages, Prentice Hall, 1981) 
     
Now, I like to focus on aesthetics, because at some level, the
  root of learning in all disciplines is learning their aesthetics:
  learning to separate the beautiful from the ugly.
Central to this discussion is the dichotomy between complexity and 
 simplicity in programming.
As is illustrated many times below, what makes programming hard is
  complexity in the tools used and complexity of the final product: it is
  too easy to create overly complicated designs and implementations (which
  inevitably are incorrect).
We must strive to keep everything simple: this is where creativity in
   programming lies.
Programming is one of many human activities in which simplicity and beauty
  are bound tightly.
  
    
The competent programmer is fully aware of the strictly limited size of his
  own skull; therefore he approaches the programming task in full humility,
  and among other things he avoids clever tricks like the plague. 
  - E. Dijkstra (in "The Humble Programmer",
   his 1972 Turing Award Lecture) 
  
Beauty is more important in computing than anywhere else in technology because
  software is so complicated.
Beauty is the ultimate defense against complexity.
...
The geniuses of the computer field, on the the other hand, are the
  people with the keenest aesthetic senses, the ones who are 
  capable of creating beauty.
Beauty is decisive at every level: the most important interfaces, the most
  important programming languages, the winning algorithms are the beautiful
  ones.
...
Good programmers know what is beautiful and bad programmers don't.
   - D. Gelernter ("Machine Beauty", Basic Books, 1998) 
  
Great software, likewise, requires a fanatical devotion to beauty.
If you look inside good software, you find that parts that no one is ever
  supposed to see are beautiful too.
When it comes to code I behave in a way that would make me eligible for
  prescription drugs if I approached everyday life the same way.
It drives me crazy to see code that's badly indented, or that uses ugly
  variable names.
   - P. Graham (in "Hackers and Painters" pg. 29) 
  
Controlling complexity is the essence of computer programming. 
   - B. Kernighan (creator of the C programming language) 
  
Fools ignore complexity; pragmatists suffer it; experts avoid it; geniuses
  remove it. ...
Simplicity does not precede complexity, but follows it.
   - A. Perlis 
  
Computer Science is the first engineering discipline in which the complexity of
  the objects created is limited solely by the skill of  the creator, and not
  by the strength of raw materials.
   - B. Reid 
  
Design and programming are human activities; forget that and all is lost. 
   - B. Stroustrup 
  
Technical skill is mastery of complexity, while creativity is mastery of
  simplicity.
   - E. C. Zeeman 
     
I'd like to present the following quote last; it will provide an import
  perpective for many of our discussions about features in the Python
  language.
It fully recognizes the psychological aspect of programming and is directly
  related to the complexity of the tools that we use when we build complex
  artifacts.
  
    
Millions for compilers, but hardly a penny for understanding human programming
  language use.
Now, programming languages are obviously symmetrical, the computer on one
  side, the human on the other.
In an appropriate science of computer languages, one would expect that half
  the effort would be on the computer side, understanding how to translate
  the languages into executable form, and half on the human side, understanding
  how to design languages that are easy or productive to use.
Yet, we do not even have an enumeration of all the psychologicial functions
  programing languages serve for the user.
Of course, there is lots of programming language  design , but it comes
  from computer scientists.
And though technical papers on languages contain mainly appeals to ease of use
  and learning, they patently contain almost no psychologicial evidence nor any
  appeal to psychological science.
  - A. Newell and S. Card 
     
    
  Software 




        System Costs  
 
In the early days, computers were built by hand, which made them expensive.
They were physcially large, consumed huge amount of power, were slow, and their
  memories were small; so they could run only small programs.
As a result, the cost of developing a working computing system was mostly spent
  on hardware.
 
At present, computers are cheaply mass produced: they are small, consume
  minimal power, are fast, and have large memories.
Now, the cost of developing a working computing system is mostly spent on
  software.
To deliver new systems cheaply and on time, we must focus on improving the
 production of software.
When implementing a computer system, a 5% improvement in developing software
  is worth about as much as a 50% improvement in developing hardware (because
  these latter costs are so minimal to start with).
  
    
   
      
 
In his Turing Award lecture, "The Humble Programmer", Edgser Dijkstra (a famous
  Computer Scientist) put it as follows: 
"As long as there were no machines, programming was no problem at all;
 when we had a few weak computers, programming became a mild problem,
 and now [1972] that we have gigantic computers, programming has become a
 gigantic problem.

 ...As the power of available machines grew by a factor of more than a
 thousand, society's ambition to apply these new machines grew in proportion,
 and it was the poor programmer who found his job in this exploded field of
 tension between the ends and the means.
 
  The increased power of the hardware, together with the perhaps more dramatic
  increase in its reliability, made solutions feasible that the programmer had
  not dared to dream about a few years before.

  And now, a few years later, he  had  to dream about them and even worse,
  he had to transform such dreams into reality! It is no wonder that we found
  ourselves in a software crisis."
   
In fact,
   Moore's "Law"  
 (empirical) states that computer/communication hardware doubles
 in performance (speed, memory) and halves in resources (size, cost) about
  every 18 months.
This exponential law has held for the past 30 years of computing, which has
  seen changes in computing technology by a factor of a million.
PCs today perform a billion operations per second; if Moore's Law continues to
  hold for another 40 years, PCs will be performing a thousand trillion
  operations per second (about as many as the human brain performs; with many
  more logical elements, each operating at a much slower -than electronic-
  speed).
      




        A Software Development Model  
 
Over the last 30 years the following model, called the
   Iterated Waterfall  model, has proven itself an important one, for
  developing large software systems (direclty applying it to smaller projects
  is a bit cumbersome, but it is often applied in a modified way).
Each higher phase must finish before a lower phase begins (like water falling),
  but there are opportunities to return to earlier phases: a problem at a later
  phase may back up to an earlier one; and all phases can be reached again
  (iterated) during maintenance.
A more recent software methodology (better adapted for smaller projects that
  require  fewer programmers) is called 
   Extreme Programming .
It shares the idea of incremental development with the iterated waterfall
  model, but reaches these objectives a bit differently.
 
    
   
      
 
 In fact, maintenance is a curious term to appply to software, because
   unlike cars, for example, 
  Software has no parts that wear out and need to be replaced
    Software has no fluids that evaporate and need to be replished
  
So what constitutes software maintenance?
  Fixing (latent) errors
     Improving performance
     Increasing functionality
     Writing new code to meet new specifications
       Redesigning/Reimplementing/Recoding
     Rewriting old code to simplify it for future (anticipated) changes
       
So software has organic features: it continues to grow and evolve.
In fact, reliably working software continues to be used a long time.
The current Air-Traffic controller system is decades old; there have
  been a few attempts to design and code a replacement, but after
  billions of dollars, little progress has been made (many say because
  the specification keeps changing: see the next chart).
     




        Relative Costs to Fix Errors  
 
Review the Iterated Waterfall model of software development.
The following chart shows the cost to fix an error, depending on when the error
  was discoved during this process.
Notice that the sooner an error is discovered, the less expensive it is to fix. 
 
    
   
      
 
When we write Python programs, we will learn about language features that allow
  us to detect errors more quickly (and thus, fix them earlier and save our
  time, which is the  biggest cost of taking this course)
     




        Software Lifetime Costs  
 
We have learned that reliably working software continues to be used a
  long time.
Therefore, the following charts should come as no surprise
 (although it typically does).
 
    
   
      
 
The upshot of this chart is that software must be built initially in such a way
  that it is easy to maintain, because over the lifetime of a product,
  maintenance costs dominate.
One easy way to remember this chart is that the  maintenance cost  looks
  like a Pac-Man icon, gobbling up the  initial cost  to build.
     




        Software Project Sizes  
 
Although we will write only small software systems in this course, we should
  still keep the construction of large software systems in mind.
As we have seen in industry, often small software systems grow into large ones.
Software project sizes are roughly categorized as follows (where K means 1,000
  lines of code and M means 1 million lines of code)
     Tiny:   
     Small:    1K - 10 K 
    Medium:    10K - 100K 
    Large:    100K - 1 M 
    Huge:    &gt; 1M 
    
Writing a very large software project is like building a skyscraper, in terms
  of workforce, cost, and timetable.
But, it is notoriously difficult to predict software costs and schedules,
  compared to the building trades.
   
While most construction jobs can be estimated within 10% of time and budget,
  software jobs are lucky to be estimated with 300%.
Something like 60% of all software projects fail to be completed or deployed.
  -many $100 million projects are abandoned, with no usable product produced.
This is known as the  software crisis , which many attribute to the
  relative newness of programming as a discipline (
The area of Software Engineering is young, but quickly growing and maturing as
  software  finds its way into everything that we produce.
  
    




        Software Project Metrics  
 
Although software projects scale many magnitudes in sizes (the ones shown below
  are medium to huge), worker productivit rates fall into a much smaller range.
The following data came from an article, "How to Break the Software Logjam"
  from  Fortune magazine, Sept. 25, 1989 (pages 100-112).
 
     Company  Product 
   Lines x1K  Time worker-yrs  Cost x$1M 
   $/Line  Lines /Month /Worker      Ford  Continental 
   84  3.5  1.8 
   21  200    IBM  Checkout Scanner 
   90  58.0  3.0 
   33  129    Lotus  1 2 3 Spreadsheet 
   400  263.0  22.0 
   55  127    Citibank  ATM* 
   780  150.0  13.2 
   17  433    NASA  Space Shuttle 
   25,600  22,100  1,200 
   47  97    
*The Citibank ATM project was considered to be very successful.
Without it, all the other metrics would differ only by a factor of 2.
 
Note that  Code Lines/Month  is a bad metric to measure programmer
  productivity.
This is because a poor programmer may quickly produce many lines to do a
 simple task; while a good programmer will carefully write fewer lines of code
  to accomplish the same task, often producing simpler and easier to modify
  code, reproducing the same functionality in fewer lines of code.
Here are two relevant quotes from my homepage (there are lots of other
  interesting and relevant quotes there).
  
    
We flew down weekly to meet with IBM, but they thought the way to measure
  software was the amount of code we wrote, when really the better the
  software, the fewer lines of code.
  - W. Gates (discussing the writing of the original
    DOS operating system) 
  
Once the engineers find out that this is how they're being evaluated
  [by how many lines of code per day they are writing]
  they'll revert to cut-and-past programming to optimize their productivity
  rating.
They'll repeat the same code logic in as many places as possible in an effort
  not to look lazy.
Long-term benefits like maintainability and portability will be sacrificed on
  account of a poorly chosen metric.
   - B. Blunden (in "Cube Farm", page 140) 
     
But  Code Lines  is a good metric to measure maintenance cost (which we
  have seen overshadows by a large fact the original cost to build software).
So, the cost of maintaining a program is roughly proportional to its size.
  
This leads to an interesting anomoly: A programmer may exhibit what appears to
  be negative productivity by working to shrink the size of a program; but, the
  result is reduced maintanence cost over the lifetime of the software.
  
     
      Problem Set  
 
Mastering programming starts with mastering the syntax (form) and semantics
 (meaning) of a programming language.
Before we begin our study of computer languages, we can investigate these
  topics in a natural language.
Although these are not questions about programming, answering them requires
  thinking like a programmer.
  
  Interpret each of the following (real) headlines in two ways; rewrite each
  in a longer but less ambiguous form.
    Police Squad Helps Dog Bite Victim
      Milk Drinkers Turn to Powder
      Kids Make Nutritious Snacks
      Stolen Painting Found by Tree
      Red Tape Holds Up New Bridge
      Old School Pillars are Replace by Alumni
      Hospitals are Sued by 7 Foot Doctors
      Earthquake! Buildings Sway from San Francisco to LA
      Tuna Biting Off Coast of Washington
      Teacher Strikes Idle Kids
      Local High School Dropouts Cut in Half
      UCI Graduates Blind Senior Citizen
      White House Ducks Report on Pornography
    
  I'm sure lots of these are available online. 
  Here is one URL for 
     
      Headlines from 1997 
   

   
  Assume that a state originally had no litter laws (so it was legal to
    litter).
  A newspaper reports, "Legaslature Voids Judge's Reversal of Governer's Veto
    of Anti-Litter Law." Is it now legal or illegal to litter?

 
   
  A man is looking at a photograph; he says of it.
    "Brothers and sisters have I none, but this man's father is my
      father's son".
    
  What is the relationship between the speaker and the person in the picture?
  What is the simplest, most convincing arguments for your answer?

 
   
  What would be a good metric to assess the productivity of letter carrier
    working for the US Post Office? Think about why a simple metric, like 
    letters delivered per day, has flaws; what other kinds of data should be
     taken into account?
  
 
   
  Assume that Company X builds a software system that comprises 250,000 lines
    of code for $1,000,000: they spent extra time to make it compact and easy
    to maintain.
  Assume that Company Y builds a software system that comprises 1,000,000 lines
    of code for $250,000: they wrote it quickly and cheaply.
  Finally, assume that it costs 20 cents/year to maintain a line of code (here
    we won't distinguish between well-/poorly-written code, just code size.
  What is the 10 year cost for each of these companies to build and maintain
    their software product? What other important issues for success are not
    covered in this simple analysis?
  Which software company is likely to thrive?
  
 
   
  Assume white clothes are best washed in hot water, but colored clothes must
    be washed in cold water (so the colors don't run).
  You have a large pile of laundry to do, which will fit in one white and one
    colored load.
  You want everything reasonably clean.
  Which load do you do first? Think about robustness in the face of errors.
  
 
   
  If you have a washing machine and dryer that each take 30 minutes to run,
    and you have 10 piles of laundry that you must wash and dry, how long will
    the entire process take (disregard the time to load/unload)?

 
   
  What is the difference between  precision  and  accuracy  (look
    these words up in a dictionary if you need to)?
  Write a precise statement that is not accurate.
  Write an accurate statement that is not precise.

 
   
  The bottom of an escalator has two signs
    Shoes must be worn!
       Dogs must be carried!
    
  Although these signs read similarly (syntax), they have very different
    interpretations (semantics), about which no native English speakers
    would give a second thought.
  Carefully examine these two sentences and explain their difference, possibly
     by restating the intent of these signs using more words.
  Hint: "Shoes must be worn!" does not refer to shoes being old/worn-out.

 
   
  Repunctuate the following sentences (you may add or remove punctuation
    marks) to reverse their meanings
    The republicans say the democrats will win.
       A woman without her man is nothing.
     
   
  Repunctuate the following paragraph (you may add or remove punctuation
    marks) to make the letter more one of loathing than admiration.
   
Dear Jack:
I want a man who knows what love is all
about. You are generous, kind, and thoughtful.
People who are not like you admit to being
useless and inferior. You have ruined me for
other men. I yearn for you. I have no feelings
whatsoever when we're apart. I can be forever happy
-will you let me be yours? Jill.
  
   
Write two different interpretations for the statement, "You
  cannot put too much water in a nuclear reactor."
Write three different interpretations for the statement, "I saw
  the man on the hill with a telescope."
       


 </body> 