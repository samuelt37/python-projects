 Candidate ICS 125 Projects FQ2003<body> Candidate Projects, FQ 2003   Raytheon: Automatic Tracking Controller   Raytheon Visualization Interface for Enhanced Analysis.   Raytheon C++/Java Message Interoperability Tool.   Raytheon Multilingual User Interface   Raytheon On-line Content Management System .  Raytheon Web Services Implementation   UCI: The Web as Middleware   UCI: PACE #1: Coalition Forces Battlefield ManagementSystem   UCI PACE #2: Decentralized Calendaring   UCI PACE #3: Collaborative InformationSpaces   Unisys: System Telemetry Warehouse Monitor   UCI:Scacchi: Web document compiler/composition system   UCI:Scacchi: Virtual Interactive Development Environment for CS Education   Wallace/IUSD: Developing a PDA System for Special Needs Students      Raytheon: Automatic Tracking Controller.   Design and develop Java-based    automatic tracking controller component that is part of larger security system.  The controller will take geo-referenced position and velocity of subject tracks  and determine appropriate pointing commands for a tracking camera mounted on  a PTZ gimbal. Select and evaluate algorithms for camera control that will allow  smooth, predictive control of the camera given various scenarios of subject  movement.     Raytheon Visualization Interface for Enhanced Analysis.   Re-engineer an existing analysis component coded in Ada83 using OO design  and the C++ language. The existing analysis component produces numeric output  in a tabular form. Design and implement a visualization interface (e.g., using  browser-based thin-client) to enhance analysts' understanding of results.     Raytheon C++/Java Message Interoperability Tool.   Develop a tool that will accept a description of a message interface definition  via some defined Interface Description Language (IDL). The tool generates the   corresponding C++ and Java classes to enable interoperability at the message  level between C++ and Java programs, including the logic for constructing the  actual messages that will be transmitted. This tool facilitates synchronization  between the two sides of the interface based on a simple interface definition.  The generated code should be portable and not dependent on any outside class  libraries, including CORBA libraries. The tool should be designed so that the  mapping from the IDL to the corresponding C++ and Java constructs is changeable  without modification  to the core of the tool.     Raytheon Multilingual User Interface.   Enhance existing English-language user interface components, currently implemented  in Java/Swing, to allow real-time user selection of one of multiple languages  (including bi-directional support    for Arabic). Identify enhancements to the XML display description/data  mapping for these components in order to support multiple  languages. Evaluate services APIs to identify changes required to support multiple  languages. Implement prototype and evaluate display performance.     Raytheon On-line Content Management System.   Identify candidate products and            tools for implementation of a web-based content management system.  The system will normalize user access to data sets hosted on a set of  diverse platforms and database products; facilitate user ability to supply  content; improve user  access to and awareness of available content through index and  search capabilities; and provide user and role-based access controls.  Implement  and evaluate a prototype system based on the selected products  and tools.     Raytheon Web Services Implementation.   Take set of existing tabular display components implemented in a J2EE framework  and re-implement using web services technologies. Evaluate HMI attributes of  the displays                and identify changes to enhance compatibility with web services  technologies. Evaluate and select appropriate Java technology for implementation  (e.g., JSP, servlets).  Document the design  patterns applied to achieve the implementation.    UCI: The Web as Middleware     Middleware is software that allows the interconnection of potentially heterogeneous    software components across process and network boundaries. Two of the most    prevalent 'flavors' of middleware are Remote Procedure Call (RPC) and Message-Oriented    Middleware (MOM). RPC is traditionally used for synchronous communication    between system components, while MOM supports asynchronous messaging. Each    of these types of middleware has advantages and disadvantages that make the    selection of one over the other a system-dependent process and each of them    have a variety of different competing implementations. The focus of this    project lies with middleware for component-based systems communicating using    asynchronous events; C2 architectures are an example of this class of system.   Distributed event-based systems require a middleware communication mechanism  in order to transmit events from one part of the system to another. Given the  inherent event-based nature of such systems, MOM seems to be the most appropriate  selection. But, the use of one of the available 'industrial strength' middleware  solutions featuring similar functionality yet disparate implementations is  not necessarily the only approach. The Web is also a platform that can be used  as a simple but powerful middleware solution. Using the Web as a form of middleware  is not an entirely new idea: [1] discusses the possibilities of using the Common  Gateway Interface (CGI) as middleware between users and underlying applications,  while [2] presents an approach to mobile computing where applications are madeavailable ubiquitously using the Web as middlware.   In this project, students will implement a Web-based middleware solution for  C2 architectures; this will be a prototype implementation and a feasibility    study which examines the reality of using the Web as a MOM solution: web    servers will be used as the connectors which both send and receive asynchronous  messages in order to construct highly distributed event-basedsystems.  There are several advantages to using web servers as middleware connectors.  First, their simplicity ˆ compared to some middlware implementations,  web servers can be rather lightweight and simple to implement and maintain.  But, most importantly, web servers have the potential of providing  useful capabilities for a low cost: the ability of a web server  to arbitrarily manage its namespace, augment it with new information,  and present it to Web browsers can provide a very high level of visibility  into the operation of the middleware connector. For example, such  a connector can easily maintain a log of all messages received and sent  including  information about failures. Or, the URLs to which a particular  web server connector links to can be presented to users and dynamically  changed through HTML forms to easily implement a small measure  of dynamic system adaptation. Leveraging web connectors in this manner and  integrating them into an architecture-based approach to system developmentis, as far as I'm aware, a novel contribution.  Features and Criteria for Success    A xADL 2.0 schema extension defining a C2 Web Connector.    This schema should make the URLs the connector links to and the types of    messages they transmit to each explicit.    A C2 connector wrapping around a lightweight, OTS web server. Students     must define and implement a clear interface encapsulating the    interaction of the C2 Connector with the web server ˆ this way, other  OTS servers can be used with less effort.    These connectors need to base their transmission behavior on the  architectural description, and update their behavior in response to the  description changing.    - These connectors must keep a log of all events received and transmitted.      A two-way translation from C2 events to an XML-based playload to be transmitted      over HTTP ˆ and vice versa.     - This must be a seperate C2 component, which then tranmits the payload to    the Web Connector for transmission.  	 Web front-end to C2 Web Connectors.     - Users must be able to access the URL of the Web Connector and be provided      HTML pages which provide access to the following information (at least):     - HTML formatted infromation from the C2&lt;-&gt;XML translator.     - Logs of messages sent/received and errors.     - The list of URLs the connector transmits to.     - This list needs to be changeable (hint: use forms to gather input, modify    the architectural model, and update the inner workings accordingly).       These components and connectors must be integrated into the C2/Archstudio      infrastructure for...       A demonstration of C2 Web Connectors using an existing C2 demonstration.     - Students must distribute a previously non-distributed system to at least      three different network locations, and demonstrate its use. KLAX, or even      Archstudio itself could be used for this.       (Time permitting) Security for point-to-point connections.     - Certificates? Students can explore this space on their own, and suggest    solutions.       Students working on this project will be exposed and acquire valuable experience  in the practical use of software architectures and accompanying research technologies  (C2, ArchStudio, c2.fw) as well as a collection of    popular andmarketable Web technologies (HTTP, HTML, XML, XSD, XSLT).   Should they decide to pursue the security problem, they'll also acquire even  more marketable skills. Background preparation will also expose students torelevant research literature.  References   [1] Faughnan, J.G. „Client-Server Computing: The Web as Middleware‰,URL: http://www.faughnan.com/papers/clservweb.html [2] Vuong, S.T. And Li, N., „WebMC: A Web-Based Middleware for Mobile Computing‰, In International Conference on Internet Computing, 2000, p. 157-164.    UCI: PACE #1: Coalition Forces Battlefield ManagementSystem  Battlefield management systems are a case of decentralized systems.  In  a coalition of military forces, there are potentially different degrees of  trust between these coalitions.  Information may only be partially shared  between battle forces or they may have differing degrees of reliability in  their reports.  There may be no trusted, central, controlling authority  that determines what is 'right' and that enforces cooperation.  Each independent  authority may have a wide range of assets that provide information that can  be relayed to others.  Malicious forces may also attempt to compromise  the integrity of the communications between these well-meaning coalition parties.  We are looking for a system that can model threats in such a system and evaluate  their effects.  Information should be collected, evaluated, and presented  to an operator who can then issue commands to units present in the field.  The  threats introduced can be direct attacks on the system, such as denial-of-service  attacks.  These threats can also be indirect by the introduction of falsified  data.  We already have a previously existing implementation of this application in  the C2 architectural style.  However, this application lacks certain critical  features, and does not explicitly consider trust.  We desire to extend  this application using PACE, a C2-based architectural style that explicitly  adds trust management.  A framework designed to support applications in  PACE has already been written.  While the framework is relatively new,  we believe it should provide guidance on how to write applications in this  style.  We believe that this project offers several benefits:  1.         An  introduction to component-based software architectures.  2.         An  introduction to the effects of decentralization on a system.  3.         An  introduction to the impact of trust and security on a system.  Features: (a short bullet list of one-line descriptions of features or requirements)  A coalition-based battlefield management system should:  -             Conform  to a particular decentralized architecture style, PACE  -             Extend  the previous C2 implementation, as desired  -             Utilize  the PACE and C2 frameworks, and the ArchStudio environment  -             Implement  multiple 'roles' in a system that fulfill the stated  -             obligations  (Each role may be on separate machines.)  -             Allow  the introduction of threats into the system on demand  -             Evaluate  the impact of these threats on the system    UCI PACE  #2: Decentralized Calendaring  As social patterns emerge, groups often attempt to coordinate their activities.  One common task is scheduling meetings.  However, these groups may be  formed on an ad hoc basis - there is no central authority that governs their  interaction.  For example, students in a class may desire to hold meetings  related to their group project.  Each user may have scheduled events that  they do not wish to share with others (i.e. a hot date on Friday night).  However,  enough information must be communicated between these users to achieve coordination  to schedule a time that works 'best' for everyone.  We are looking for a calendaring application that allows collaboration between  users who may or may not trust each other.  Each user may have a variety  of calendars that they are only willing to share with other users. Additionally,  the system should be able to suggest times when all prospective attendees can  meet based on the visible information to the person creating the appointment.  Notifications (i.e. emails) should be transmitted when someone is scheduled  for an appointment.  We desire to write this application in the PACE architectural style, a new  C2-based architectural style that introduces explicit trust management and  supports a variety of communication mechanisms.  A framework designed  to support applications in PACE has already been written.  While the framework  is relatively new, we believe it should provide guidance on how to write applications  in this style.  We believe that this project offers several benefits:   An introduction to component-based software architectures.    An introduction to the effects of decentralization on a system.    An introduction to creating effective user interfaces.   Features: (a short bullet list of one-line descriptions of features or requirements)  A decentralized calendaring system should:  -             Conform  to a particular decentralized architecture style, PACE  -             Utilize  the PACE and C2 frameworks, and the ArchStudio environment  -             Provide  a usable interface that supports a variety of expertise levels  -             Have  no central storage  -             Support  different degrees of notification and automation    UCI PACE #3: Collaborative Information Spaces  Sharing information between people can be an important tool to increasing  productivity and knowledge.  However, different sources of information  may represent varying levels of expertise about a topic.  For example,  a person may be known to be a real expert on movies, but doesn't know a lot  about automobiles.  Therefore, you may decide to place trust in his reviews  of movies, but not as much confidence about fixing your car.   We desire the creation of a system that facilitates the creation, distribution,  annotation, and review of information without a central, trusted authority.  This  information may be any free-form textual data. Users may encounter conflicting  reports about the evaluations of the reported data, and need the ability to  make accurate assessments of the correctness/worthiness of the data.  We desire to write this application in the PACE architectural style, a new  C2-based architectural style that introduces explicit trust management and  supports a variety of communication mechanisms.  A framework designed  to support applications in PACE has already been written.  While the framework  is relatively new, we believe it should provide guidance on how to write applications  in this style.  We believe that this project offers several benefits:  1.         An  introduction to component-based software architectures.  2.         An  introduction to the effects of decentralization on a system.  3.         An  introduction to the concept of independent evaluations of data.  Features: (a short bullet list of one-line descriptions of features or requirements)  A collaborative information spaces system should:  -             Conform  to a particular decentralized architecture style, PACE  -             Utilize  the PACE and C2 frameworks, and the ArchStudio environment  -             Provide  the ability to input notes about a topic or event  -             Distribute  these notes to other users  -             Allow  for the annotation of these notes by others (and redistribution)  -             Provide  evaluations about the accuracy of these notes  -             Provide  a usable interface for managing the received data    Unisys: System Telemetry Warehouse Monitor  Summary - Provide  a GUI for monitoring system performance data stored in the System TelemetryWarehouse.     Background – The System Telemetry Warehouse provides a consolidated system  log in the form of a data warehouse. The System Telemetry Warehouse can contain  data collected from traditional sources such as PerfMon counters and system  event logs. Additionally, information regarding application and system softwarecomponents can be collected.     Desired Product – A graphical, time-based monitor of data contained in  the warehouse. When initiated, the monitor should show the values for a default  set of counters at the current time. Users should be able to change the counters  being displayed by selecting from a list of counters available in the warehouse.  They should also be able to change the default set of counters. Some counters  are aggregations, for example cpu usage for all processors. Users should be  able to drill down or expand such counters to their component values,  for example cpu usage for each processor. A slider should be provided allowing  users to change the time slice displayed. If the current time slice is displayed,  there should be an option to have it  updated automatically at periodic intervals. Users should also be able to start  at a prior point in time, and have the monitor move forward in an acceleratedor "time-lapse" sort of mode.     Deliverables ∑   Monitor software ∑   Installation instructions ∑   Usage instructions ∑   Design description   Required – SQL Server 2000. The implementation language is at the students’ discretion.   Unisys provides – The System Telemetry Warehouse schema  and data collection subsystem for PerfMon counters and event logs. This includes  installation instructions  and help text.    Scacchi:Web document compiler/composition system  Many people want to be able to create documents using materials/content  appearing in Web site pages. However, the Web is primarily a reading/browsing  medium,  rather than a writing medium. A Web document compiler is envisioned as an application  that allows a user to "cut" selected contents from a Web page (text,  images, embedded hyperlinks, mp3 files, etc.) and then "paste" the  selected content into a new document/Web page, that captures the selected content,  as well as the URL from where it was selected, information (anchors? tags?)  to indicate where the selected content begins and ends, and a timestamp when  it was cut-and-pasted as a way to maintain a relation to the source of the  document components. The composed document can also include new content entered/edited  by the user. The resulting document composition record (or "build" script)  might then function like a "make" file, allowing the user to rebuild  the composed document from its sources at a later time/place. This might allow  the user to then observe which document components have changed since a previous  compilation. Such a capability might then allow the user to also share their  document compilation scripts with their friends so that others could compile  the same document components, or compose new documents or modified versionsof shared documents, when using the Web document compiler/composition system.  What do they really need to do? Build a simple compile/build  utility that processes an explicit representation of a multi-part or multi-component      document to produce  a compiled document.  What makes this project challenging? Users can already manually  compose a new document by selecting and cut-and-paste existing document contents.      This is      often not a repeatable or shareable technique, nor does it allow for new      versions of the composed document to be compiled/built on demand, given      that the source  content may have changed since the previous document build.  What makes it worth doing?   More and more people want to create and shared Web-based documents whose        contents can be updated automaticaly, rather than manually. For instance,        if I want        to create a selection of sharable mp3/text files that can be burned on        a CD, then share my selection with a friend who wants most of the same        mp3/text        files,        but wants to add/remove one or more files, then it would be nice to have        easy way for sharing composable document scripts, rather than just sharing        the raw  mp3/text files.       Scacchi: Virtual Interactive Development Environment for CSEducation   What is it? An Interactive Development  Environment is usually an integrated collection of services, utilities, or  tools that      can be used to support the development of software application systems/programs.    Java-based IDEs like Visual Cafe, BlueJ for Java, and Rational Rose are large    commercial products, while NetBeans (from netbeans.org) and Eclipse (eclipse.org)    are free, open source IDEs implemented in Java, supporting the development    of Java applications. However, there are many other (open source) software    tools/utilities that may be useful for developing certain kinds of application    systems (e.g., database management systems, expert system shells, computer    graphics libraries, user interface development kits, computer-aided software    design, computer game engines, etc.). Furthermore, it now appears that it      should    be possible to find and collect dozens of open source tools, where one or      more tools might be of use in different CS undergraduate courses.   What do they really need to do? Find and collect a bunch of  open source tools. The tools may reside and operate on remote network servers,  rather than on  each user's computer.  Build a user interface that presents a end-user/student with  grouped sub-sets of tools associated with different CS course types (e.g.,  for a course in database  management, tools like MySQL, PostgreSQL, BerkeleyDB, and SAP-DB might be grouped,  together with tools for Java-SQL (or JODBC) dbms program development). In a  Virtual IDE, tool integration need only be realized at the user interface level,  (i.e., an "integrated collection") rather than integrated via coding  at the API or middleware level as would be necessary in a conventional IDE.  So low-level systems programming may be avoided, since this is mostly a user  interface level, virtual IDE.     What makes this project challenging? Supporting tools that execute on remote    servers. Managing the transfer of tool input/output between user-clients      and remote servers. Moving tool input/output in/out of distributed repositories/file    servers. Designing the user interface so that different collections of tools    can be organized and presented for different types of CS courses, and different  CS course instances.     What makes it worth doing?   Wouldn't it be nice to have one overall computing environment where all the      software tools you need to use in your CS courses could be found, collected,  organized, and used across the Internet.    Wallace/IUSD:   Developing a PDA System for Special Needs Students    The Irvine Adult Transition Program (IATP) would  like to initiate a pilot project on the application of PDA technology to the  needs of developmentally disabled young adults who are transitioning from high  school to adult living and job situations.  Three separate application  areas have been identified.  Pilot projects will focus on applying or  developing software to meet the individual needs of a single student in each  application area.  The results of these trial applications will be used  in future projects to expand the applications to be useful to a broader range  of students in the program and/or to target new application designs .       Description of the Irvine Adult Transition      Program (IATP)    The Irvine Adult Transition Program (IATP) is a post-high school program for  developmentally disabled young adults who are between the ages of 19 and 22  years.  The fifteen students in the program receive classroom instruction  in the morning at Irvine Valley College on life skills and vocational skills.  In  the afternoon they work at   various jobs  in Irvine with the support of job coaches.  All of the students are currently  competent in the use of cell phone technology.  Expanding the program  to include training in and use of PDA technology is a logical next step which  would be beneficial to students, staff, and employers.                  Irvine Adult Transition    Program (IATP) Students and Staff     Potential PDA Applications to IATP               There  are initially three areas in which PDA technology and existing software which  IATP staff feel might be most useful to the needs of students in the IATP:  money management, memo or �to-do� check lists and calendar and scheduling.                1.  Money    management  should include such elements as calculating the expense of    an individual item or set of items including tax and/or tip; record keeping    of expenditures during an activity or over a period of time; storing and    managing bank account records; and long term budget planning and record keeping.              2.  Memo    or �to-do� check lists  should include systems for staff to enter lists    of job duties for students to perform in sequence and which students could    check-off as they were completed; lists or memos of behavioral goals for    students to monitor during the day; templates for regular record recording    by students of staff during the day concerning job or behavioral goals.              3.  Calendar    and scheduling  should begin with templates for transportation schedules    of an individual student to work and other activities during the day and    the week.  It should also include a system for inputting the OCTA bus    schedules for those routes (from departure point to destination) for an individual    student.              Obviously,  there are many more complex and elaborate uses of the PDA technology and existing  or developed software which could benefit the students and the program.  The  initial goal is to test the effectiveness for a few students with specific  goals as a guideline for future development.    Proposed Steps in Pilot Study    IATP staff has identified three students from the program whose needs will  serve as the model for purposes of developing pilot software in each of the  three application areas mentioned above (i.e., one student per application  area). Students from Dr. Taylor�s Computer Projects course at UCI will be invited  to select one of the three application areas.  To avoid confusion, there  should be a maximum of three teams, each working on a separate application  area.  The IATP, with the advice from UCI computer experts, will purchase the necessary  PDA�s for students and staff to use in the pilot project.  It is expected  that one system will be selected for use, to avoid confusion and to allow the  eventual use of all applications by all IATP students as appropriate to their  needs.  The UCI team(s) will meet with IATP staff and students at Irvine Valley College  to become acquainted with the program and with the specific student whose needs  are associated with the application they have chosen.  UCI teams will  apply or develop software, test it with the IATP student and staff, modify  it if necessary on the basis of findings, and make proposals for further development  and applications.  </body> 