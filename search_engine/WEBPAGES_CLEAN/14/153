 Lab Assignment 3<body>

 
 
 Smileys at the Races 
 Lab Assignment 3 
to prepare for Lab Exam 3 
 
 

 In this assignment you write a program where smileys run a race and, at races end, shows statistics about the racers running times. The assignment gives you practice with simple uses of ArrayLists and additional practice with boolean expressions,  if  statments, loops and nested structures. 

 
  Program Behavior and General Requirements 
 

 This program begins with smiley racers, on the left edge of the graphics display, facing right; we see them in profile. They each have a name displayed, in color, in the middle of their faces, so we can root for our favorite.  

 The race begins when the user presses the  Go!  button; these racers then begin moving to the right. When a smiley hits the right wall, its completed a lap. The smiley then reverses direction (so that it is facing left), its speed is adjusted (as discussed below), and it heads for the left wall. When it hits the left wall, again the profile and direction are reversed, the speed is again adjusted, and the racer heads for the right wall; another lap has been completed. As the race is run, the number of laps a smiley has completed so far is displayed next to its name.  

 When a racer completes the race—that is, runs the number of laps that constitue a race—the smiley stops. When all racers finish the race, the stats box at the bottom of the window shows the name and time of the fastest racer, the name and time of the slowest racer, and the average of all the racers times.

  The program then stops; the window remains open so the user can read the statistics. The user clicks on the close box to close the window and end the program; if the close box is clicked while the race is still running, the program still shuts down. 

 
  Technical Details 
 

 For this assignment, weve again helped you get started by providing a significant amount of code and lots of comments and documentation. All your work is done in the SmileyAnimation and SmileyRacer classes. Weve provided several classes in compiled form; three of them (SmileyFace, SmileyFacePart, and SmileyDisplay) have public methods and constants that you may need, so weve included text files describing each of them. Note that SmileyFace and SmileyFacePart as the same as they were in Lab 2; we explain why below. 

 Some additional technical details: 
   Each smiley racer is a smiley face with additional characteristics; each has all the attributes of a smiley face plus its name, the names display color, and information to track its status while it races, such as which lap it is on, which direction it is moving, and whether it has finished the race. So, the SmileyRacer class is  extended  from the SmileyFace class; it automatically has all the characteristicsall the fields, constants and methodsof the SmileyFace class. We then added additional fields, constants and methods to turn the smiley into a racer. The upshot of this is that all the public methods available to manipulate or access smiley faces and their face parts are available for manipulating and accessing smiley racers and their face parts. You will not see these methods explicitly listed in the SmileyRacer class, but they are available to it.  Note that what makes up a smiley face and its parts has not changed; thats why we can reuse the SmileyFace and SmileyFacePart classes from the last assignment.   

  Thus, to construct a racer, you first construct a smiley face, and set its attributes as needed (see below). You then pass this smiley face into the smiley racer constructor, along with the racers name and name color. The constructor will use the smiley faces attributes to set the same attributes in the smiley racer.   

  You can also pass an exisiting smiley racer into the smiley racer constructor (along with a new name and color for it). This works because a smiley racer is a smiley face (albeit one with additional characteristics), so the constructor will treat it as a smiley face.  

  To avoid having to write new methods to make the smiley appear in profile, make use of a couple of tricks: 

   To start, make the left eye the same color as the face and the right eye a different color; switch those colors each time a wall is hit. (Think about it it does work!)  
  Place the mouth on the smiley so that the x coordinate of its center is about the same as the x coordinate of the right-most point of the smiley face; make it the same color as the displays background color,  SmileyDisplay.BACKGROUND_COLOR . This will make the smiley appear to have an open mouth. Shift the mouth to the other side of the face each time a wall is hit. 
  

  Position your smileys so that, when they move left to right and right to left, they will not collide. You do not have to worry about constructing smiley faces so that, when the race starts,  their left sides touch the left-hand side of the race track; the racer constructor will translate them therewhenever feasible, it is best to have the program handle tasks, like this one, that would be tedious for a user. 

 To do the positioning, the constructor uses a smiley racer method called getLeftEdge(). You may well find using getLeftEdge() in a couple of methods you are to write will simplify their implementation.  

  We measure time in ticks. A tick is just an arbitrary time unit that corresponds roughly to the time between one frame of animation and the next, kind of like saying 24 frames per second means that the time between one frame of film and the next is 1/24th of a second; the 1/24th of a second would be a tick. The duration of a tick is set by a constant in the SmileyAnimation class.  

  The racers base speed is in units of pixels per tick, and is determined when the racer is constructed. Also randomly determined at that time is the racers racing strategy. A racer can run the race at a constant speed, or it can decrease its speed the same amount each lap (it peaks early) or it increases its speed the same amount each lap (it paces itself and gradually pushes harder). Of course, when decreasing its speed, it cannot go to zero and still finish the race, so the racer must move at least 1 pixel per tick. The fastest a racer can go is double its starting speed.  

  It is possible for two or more racers to run the race in the same numbers of ticks; that is, there can be ties. To simplify stats computations, if there is a tie for the fastest runner, you can declare any of those tied racers as the fastest; the same applies for identifying the slowest (good sport) racer. (The computation and display logic to list all the fastest and/or slowest racers in the case of ties is fairly complex, and beyond what is needed to practice the concepts this lab covers.)    

  Be particularly careful that, once a racer has finished the race, it does not move. A common error is for the racer to have finished, but to be moved one more time before the program knows not to move it further. The result is often a racer facing the wrong way at the finish, and not touching the finish lineand that an error!  

  Your program should work for zero racers. All that happens is that, when the progam is run, the stats screen immediately displays a message that there was no raceand it does  do not display any statistics. Your program should also handle a large number of relatively small-sized racers, at least in the range of 10 to 20. The animation may slow down when the number of racers is large, and the racers names may go outside the smileys face; that is acceptable.   
  As before, all the class and Java source files you need have been placed into an Eclipse project and zipped into an archive; download
   21Lab3.zip    to get it. Using the same procedure that you followed previously, import this project into your Eclipse workspace. 

 Do remember to test your program incrementally, as described in Assignment 2; it will very likely save you a lot of time and frustration! 


 
  About Lab Exam 3 
 

 Lab exam 3 will be very similar, but perhaps not identical, to the program you are to write for this assognment. You will be asked to code one or more of the following methods: 

 From the SmileyAnimation class: 
  the constructor 
 animate 
 computeRaceStatistics 
 computeFastestRunner 
 computeSlowestRunner 
 computeAverageTime 
 allRacersFinished   From the SmileyRacer class: 
  the constructor 
 finishedRace 
 raceForOneTick 
 moveForwardOnePixel 
 reverseProfile 
 hitSomething 
 hitLeftWall 
 hitRightWall 

  Remember to read over  INSTRUCTIONS!.txt  and program comments before beginning; they will tell you what you are to complete. 

 Also recall that a significant failure to follow class style standards on a lab exam can result in a not pass for that exam. In particular, do not use a  break  statement other than as the last line of a  case  block in a  switch  statement. 

  
Written by Norman Jacobson for ICS 21 Fall 2006, October 2006.
 Revised by Norman Jacobson to explain how  to set the smile properly and to discuss the Go button, November 2006.
 Minor editing for clarity, by Norman Jacobson, December 2006, September 2008.
 Updated to reflect use of Eclipse by Norman Jacobson, September 2009. 
   Includes some text adapted from Alex Thornton's "Lab 3" for ICS 21 Summer 2009.
 Minor edits, by Norman Jacobson, September 2010.
 Updated to discuss use of getLeftEdge(), by Norman Jacobson, December 2010.
 



</body> 